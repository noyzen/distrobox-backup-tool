// Filename: distrobox-tool.go
package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strconv"
	"strings"
	"syscall"
	"time"
)

// --- Configuration & Constants ---

// ANSI color codes for beautiful output
const (
	colorReset     = "\033[0m"
	colorRed       = "\033[31m"
	colorGreen     = "\033[32m"
	colorYellow    = "\033[33m"
	colorBlue      = "\033[34m"
	colorMagenta   = "\033[35m"
	colorCyan      = "\033[36m"
	colorWhite     = "\033[37m"
	colorBold      = "\033[1m"
	colorUnderline = "\033[4m"
)

// Container represents a distrobox container with its properties
type Container struct {
	Name  string
	ID    string
	Image string
}

// Minimal struct to unmarshal json output from 'podman/docker inspect'
type inspectData struct {
	ID     string `json:"Id"`
	Name   string
	Config struct {
		Image  string            `json:"Image"`
		Cmd    []string          `json:"Cmd"`
		Labels map[string]string `json:"Labels"`
	} `json:"Config"`
}

var (
	containerRuntime     string // Will be "podman" or "docker"
	guiFilePicker        string // Will be "zenity" or "kdialog"
	distroboxVersion     string
	hostDistroName       string
	hasTar               bool // Tracks if the 'tar' command is available
	containerStoragePath string
)

// --- Main Application Logic ---

func main() {
	clearScreen()
	checkDependencies()
	printHeader()

	for {
		containers, err := getContainers()
		if err != nil {
			logError("Could not list Distrobox containers. Is distrobox installed and running correctly?")
			logError(err.Error())
			os.Exit(1)
		}

		displayMenu(containers)

		keepLooping, actionWasTaken := handleUserChoice(containers)
		if !keepLooping {
			return
		}

		if actionWasTaken {
			fmt.Printf("\n%sPress Enter to return to the main menu...%s", colorCyan, colorReset)
			readUserInput()
		}
	}
}

// --- Core Feature Handlers ---

func handleUserChoice(containers []Container) (bool, bool) {
	fmt.Printf("%s> Select an option: %s", colorBold, colorReset)
	choiceStr := readUserInput()
	if choiceStr == "" {
		return true, false
	}
	choice, err := strconv.Atoi(choiceStr)
	if err != nil {
		logWarning("Invalid option. Please enter a number.")
		time.Sleep(2 * time.Second)
		return true, false
	}

	if choice >= 1 && choice <= 6 && len(containers) == 0 {
		logWarning("There are no containers to perform this action on.")
		time.Sleep(2 * time.Second)
		return true, false
	}

	switch choice {
	case 1:
		handleBackup(containers)
	case 2:
		handleRestore()
	case 3:
		handleClone(containers)
	case 4:
		handleEdit(containers)
	case 5:
		handleDelete(containers)
	case 6:
		handleHealthCheck(containers)
	case 7:
		fmt.Printf("\n%süëã Goodbye!%s\n", colorCyan, colorReset)
		return false, false
	default:
		logWarning("Invalid option. Please try again.")
		time.Sleep(2 * time.Second)
		return true, false
	}
	return true, true
}

func handleBackup(containers []Container) {
	clearScreen()
	fmt.Printf("%s%süì¶ Backup Container%s\n\n", colorBold, colorGreen, colorReset)
	printContainerList(containers)

	containerIndex := selectItem("Enter the number of the container to backup", len(containers))
	if containerIndex == 0 {
		return
	}
	selectedContainer := containers[containerIndex-1]

	logInfo("Please choose a backup destination folder.")
	destDir, err := selectDirectory("Select Backup Folder")
	if err != nil || destDir == "" {
		logError("No valid destination directory selected. Aborting.")
		time.Sleep(2 * time.Second)
		return
	}

	logWarning("Please ensure the destination has enough free space for the backup.")

	fmt.Printf("%s> Enter a base name for the backup file (e.g., 'ubuntu-dev'): %s", colorBold, colorReset)
	backupNameBase := readUserInput()
	if backupNameBase == "" {
		logWarning("Backup name cannot be empty. Aborting.")
		time.Sleep(2 * time.Second)
		return
	}

	isIsolated, isolatedHomePath := isContainerIsolated(selectedContainer.Name)
	backupTypeSuffix := "-standard"
	if isIsolated {
		backupTypeSuffix = "-isolated"
	}
	backupFile := filepath.Join(destDir, backupNameBase+backupTypeSuffix+".tar")

	backupMode := 1
	if isIsolated {
		if !hasTar {
			logWarning("The 'tar' command was not found, so only a Combined backup is possible.")
		} else {
			clearScreen()
			fmt.Printf("%s%süì¶ Backup Options for Isolated Container%s\n\n", colorBold, colorGreen, colorReset)
			logInfo(fmt.Sprintf("Container '%s' is ISOLATED.", selectedContainer.Name))
			fmt.Printf("\n  %s1)%s %sCombined Backup%s (Recommended)\n", colorGreen, colorReset, colorBold, colorReset)
			fmt.Printf("     Creates one file: %s%s%s\n\n", colorCyan, filepath.Base(backupFile), colorReset)
			fmt.Printf("  %s2)%s %sSeparated Backup%s\n", colorBlue, colorReset, colorBold, colorReset)
			fmt.Printf("     Creates two files, one for the image and one for the home directory.\n\n")
			backupMode = selectItem("Select backup type", 2)
			if backupMode == 0 {
				logInfo("Backup cancelled.")
				time.Sleep(2 * time.Second)
				return
			}
		}
	}

	if _, err := os.Stat(backupFile); err == nil {
		fmt.Printf("%s‚ö†Ô∏è  File '%s' already exists. Overwrite? (y/N): %s", colorYellow, backupFile, colorReset)
		if !confirmAction() {
			logInfo("Backup cancelled by user.")
			time.Sleep(2 * time.Second)
			return
		}
	}

	logInfo(fmt.Sprintf("Backing up '%s' to '%s'...", selectedContainer.Name, backupFile))
	tempImageName := fmt.Sprintf("distrobox-backup-%s:%d", selectedContainer.ID, time.Now().Unix())
	done := make(chan bool)
	go showSpinner("Processing container image...", done)

	_, err = runCommand(containerRuntime, "commit", selectedContainer.Name, tempImageName)
	done <- true
	if err != nil {
		logError("Failed to commit container.")
		logError(err.Error())
		time.Sleep(5 * time.Second)
		return
	}

	defer func() {
		logInfo(fmt.Sprintf("Cleaning up temporary image %s...", tempImageName))
		_, errRmi := runCommand(containerRuntime, "rmi", tempImageName)
		if errRmi != nil {
			logWarning(fmt.Sprintf("Failed to clean up temporary image '%s'. You may want to remove it manually with '%s rmi %s'.", tempImageName, containerRuntime, tempImageName))
		}
	}()

	_, err = runCommand(containerRuntime, "save", "-o", backupFile, tempImageName)
	if err != nil {
		logError("Failed to save image to tar file.")
		time.Sleep(5 * time.Second)
		return
	}
	logSuccess("‚úÖ Image backup completed successfully!")

	if isIsolated && backupMode == 2 && hasTar {
		homeBackupFile := strings.TrimSuffix(backupFile, ".tar") + "-home.tar.gz"
		if _, err := os.Stat(homeBackupFile); err == nil {
			fmt.Printf("%s‚ö†Ô∏è  File '%s' already exists. Overwrite? (y/N): %s", colorYellow, homeBackupFile, colorReset)
			if !confirmAction() {
				logInfo("Home directory backup cancelled. The image backup was still created.")
				time.Sleep(3 * time.Second)
				return
			}
		}

		doneHome := make(chan bool)
		go showSpinner("Archiving home directory...", doneHome)
		_, err := runCommand("tar", "-czf", homeBackupFile, "-C", isolatedHomePath, ".")
		doneHome <- true

		if err != nil {
			logError("Failed to backup home directory.")
			logError(err.Error())
		} else {
			logSuccess("‚úÖ Home directory backup completed successfully!")
		}
	}
	fmt.Println()
	logSuccess("Backup process finished.")
	time.Sleep(1 * time.Second)
}

func handleRestore() {
	clearScreen()
	fmt.Printf("%s%süì¶ Restore Container%s\n\n", colorBold, colorCyan, colorReset)

	logInfo("Please choose a backup file (.tar) to restore.")
	backupFile, err := selectFile("Select Backup File", "*-standard.tar", "*-isolated.tar")
	if err != nil || backupFile == "" {
		logError("No backup file selected. Aborting.")
		time.Sleep(2 * time.Second)
		return
	}

	backupFileInfo, err := os.Stat(backupFile)
	if err != nil {
		logError("Could not read backup file info. Aborting.")
		time.Sleep(3 * time.Second)
		return
	}
	requiredSpace := uint64(backupFileInfo.Size())
	freeSpace, err := getFreeDiskSpace(containerStoragePath)
	if err != nil {
		logWarning(fmt.Sprintf("Could not determine free disk space in %s. Continuing at your own risk.", containerStoragePath))
	} else if freeSpace < requiredSpace {
		logError(fmt.Sprintf("Not enough disk space in container storage! Required: ~%s, Available: %s.", formatBytes(requiredSpace), formatBytes(freeSpace)))
		time.Sleep(5 * time.Second)
		return
	}

	homeBackupFile := strings.TrimSuffix(backupFile, ".tar") + "-home.tar.gz"
	hasHomeBackup := false
	if _, err := os.Stat(homeBackupFile); err == nil {
		hasHomeBackup = true
		logInfo("Separated home directory backup found! This will be restored as an ISOLATED container.")
	}

	logInfo(fmt.Sprintf("Loading image from '%s'...", backupFile))
	done := make(chan bool)
	go showSpinner("Loading image...", done)
	output, err := runCommand(containerRuntime, "load", "-i", backupFile)
	done <- true
	if err != nil {
		logError("Failed to load image from backup file.")
		logError(err.Error())
		time.Sleep(5 * time.Second)
		return
	}

	loadedImage := ""
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if strings.Contains(line, "Loaded image:") {
			parts := strings.SplitN(line, "Loaded image:", 2)
			if len(parts) == 2 {
				loadedImage = strings.TrimSpace(parts[1])
				break
			}
		}
	}

	if loadedImage == "" {
		logError("Could not determine the name of the loaded image. Aborting.")
		runCommand(containerRuntime, "rmi", loadedImage)
		time.Sleep(3 * time.Second)
		return
	}
	logSuccess(fmt.Sprintf("Image '%s' loaded successfully.", loadedImage))

	defer func() {
		if loadedImage != "" {
			runCommand(containerRuntime, "rmi", loadedImage)
		}
	}()

	fmt.Printf("\n%s> Enter a name for the new container: %s", colorBold, colorReset)
	containerName := readUserInput()
	if containerName == "" {
		logWarning("Container name cannot be empty. Aborting.")
		time.Sleep(2 * time.Second)
		return
	}

	restoreType := 1
	if strings.HasSuffix(backupFile, "-isolated.tar") {
		logInfo("Backup file indicates this should be an ISOLATED container.")
		restoreType = 2
	} else if hasHomeBackup {
		restoreType = 2
	} else {
		logInfo("Backup file indicates this should be a STANDARD container.")
	}

	fmt.Printf("\n%s> Enable systemd (init) for this container? (y/N): %s", colorBold, colorReset)
	enableInit := confirmAction()

	// --- NEW ---
	fmt.Printf("%s> Attempt NVIDIA GPU integration? (Requires host drivers) (y/N): %s", colorBold, colorReset)
	enableNvidia := confirmAction()
	// --- END NEW ---

	args := []string{"--name", containerName, "--image", loadedImage}
	if enableInit {
		args = append(args, "--init")
	}
	// --- NEW ---
	if enableNvidia {
		args = append(args, "--nvidia")
	}
	// --- END NEW ---

	if restoreType == 2 {
		isolatedHomePath, err := getIsolatedHomePath(containerName)
		if err != nil {
			logError("Could not determine user home directory. Aborting.")
			time.Sleep(3 * time.Second)
			return
		}
		args = append(args, "--home", isolatedHomePath)
		logInfo(fmt.Sprintf("Creating new %sISOLATED%s container '%s'...", colorBold, colorReset, containerName))
	} else {
		logInfo(fmt.Sprintf("Creating new %sSTANDARD%s container '%s'...", colorBold, colorReset, containerName))
	}

	done = make(chan bool)
	go showSpinner("Creating container...", done)
	_, err = runCommand("distrobox-create", args...)
	done <- true

	if err != nil {
		logError(fmt.Sprintf("Failed to create container '%s'.", containerName))
		logError(err.Error())
		logInfo(fmt.Sprintf("The loaded image '%s' was kept for manual recovery.", loadedImage))
		time.Sleep(5 * time.Second)
		return
	}

	if hasHomeBackup && restoreType == 2 {
		if !hasTar {
			logError("The 'tar' command is required but was not found.")
			logWarning(fmt.Sprintf("Container created, but home must be restored manually from: %s", homeBackupFile))
		} else {
			isolatedHomePath, _ := getIsolatedHomePath(containerName)
			logInfo("Restoring home directory...")
			os.RemoveAll(isolatedHomePath)
			os.MkdirAll(isolatedHomePath, 0755)

			doneHome := make(chan bool)
			go showSpinner("Extracting home directory...", doneHome)
			_, err := runCommand("tar", "-xzf", homeBackupFile, "-C", isolatedHomePath)
			doneHome <- true

			if err != nil {
				logError("Failed to restore home directory.")
				logError(err.Error())
			} else {
				logSuccess("‚úÖ Home directory restored successfully!")
			}
		}
	}

	logSuccess(fmt.Sprintf("‚úÖ Container '%s' restored successfully!", containerName))
	loadedImage = ""
	time.Sleep(1 * time.Second)
}

func handleClone(containers []Container) {
	clearScreen()
	fmt.Printf("%s%süß¨ Clone Container%s\n\n", colorBold, colorCyan, colorReset)
	printContainerList(containers)
	fmt.Printf("%s%sHint:%s Cloning creates an exact copy of a container with a new name.\n\n", colorYellow, colorUnderline, colorReset)

	containerIndex := selectItem("Enter the number of the container to clone", len(containers))
	if containerIndex == 0 {
		return
	}
	sourceContainer := containers[containerIndex-1]

	logWarning("Please ensure you have enough free space in your container storage.")

	var cloneName string
	for {
		fmt.Printf("%s> Enter a name for the new cloned container: %s", colorBold, colorReset)
		cloneName = readUserInput()
		if cloneName == "" {
			logWarning("Clone name cannot be empty.")
			continue
		}
		if cloneName == sourceContainer.Name {
			logWarning("The clone's name cannot be the same as the source.")
			continue
		}
		nameExists := false
		for _, c := range containers {
			if c.Name == cloneName {
				nameExists = true
				break
			}
		}
		if nameExists {
			logWarning(fmt.Sprintf("A container named '%s' already exists.", cloneName))
			continue
		}
		break
	}

	logInfo(fmt.Sprintf("Cloning '%s' to '%s'...", sourceContainer.Name, cloneName))
	isIsolated, _ := isContainerIsolated(sourceContainer.Name)
	if isIsolated {
		logInfo("Source is an ISOLATED container. The clone will also be isolated.")
	} else {
		logInfo("Source is a STANDARD container. The clone will also be standard.")
	}

	done := make(chan bool)
	go showSpinner("Cloning in progress...", done)

	tempImageName := fmt.Sprintf("distrobox-clone-%s:%d", sourceContainer.ID, time.Now().Unix())
	_, err := runCommand(containerRuntime, "commit", sourceContainer.Name, tempImageName)
	if err != nil {
		done <- true
		logError("Failed to create temporary image from source container.")
		logError(err.Error())
		time.Sleep(5 * time.Second)
		return
	}

	defer func() {
		if tempImageName != "" {
			logInfo(fmt.Sprintf("Cleaning up temporary image %s...", tempImageName))
			_, errRmi := runCommand(containerRuntime, "rmi", tempImageName)
			if errRmi != nil {
				logWarning(fmt.Sprintf("Failed to clean up temporary image '%s'. You may want to remove it manually with '%s rmi %s'.", tempImageName, containerRuntime, tempImageName))
			}
		}
	}()

	done <- true

	args := []string{"--name", cloneName, "--image", tempImageName}
	if isIsolated {
		newIsolatedHome, _ := getIsolatedHomePath(cloneName)
		args = append(args, "--home", newIsolatedHome)
	}
	_, err = runCommand("distrobox-create", args...)

	if err != nil {
		logError(fmt.Sprintf("Failed to create the cloned container '%s'.", cloneName))
		logError(err.Error())
		logInfo(fmt.Sprintf("The temporary image '%s' was kept for manual recovery.", tempImageName))
		time.Sleep(5 * time.Second)
		return
	}

	logSuccess(fmt.Sprintf("‚úÖ Container '%s' successfully cloned to '%s'!", sourceContainer.Name, cloneName))
	tempImageName = ""
	time.Sleep(1 * time.Second)
}

// FIX: Simplified the entire handleEdit function to only support converting container type.
func handleEdit(containers []Container) {
	clearScreen()
	fmt.Printf("%s%süîß Edit Container Type%s\n\n", colorBold, colorMagenta, colorReset)
	printContainerList(containers)
	containerIndex := selectItem("Enter the number of the container to edit", len(containers))
	if containerIndex == 0 {
		return
	}
	selectedContainer := containers[containerIndex-1]
	isIsolated, isolatedHomePath := isContainerIsolated(selectedContainer.Name)

	clearScreen()
	fmt.Printf("%s%süîß Editing '%s'%s\n\n", colorBold, colorMagenta, selectedContainer.Name, colorReset)
	fmt.Printf("  %sCurrent State:%s\n", colorBold, colorReset)
	var currentType, targetType string
	if isIsolated {
		currentType = "Isolated"
		targetType = "Standard"
		fmt.Printf("  - Type: %s%s%s\n\n", colorBlue, currentType, colorReset)
		fmt.Printf("%s> Convert '%s' to %s? This will PERMANENTLY DELETE its isolated home folder. (y/N): %s", colorRed, selectedContainer.Name, targetType, colorReset)
	} else {
		currentType = "Standard"
		targetType = "Isolated"
		fmt.Printf("  - Type: %s%s%s\n\n", colorGreen, currentType, colorReset)
		fmt.Printf("%s> Convert '%s' to %s? (y/N): %s", colorBold, selectedContainer.Name, targetType, colorReset)
	}

	if !confirmAction() {
		logInfo("Edit cancelled.")
		time.Sleep(1 * time.Second)
		return
	}

	var args []string
	if isIsolated { // Converting to Standard
		args = []string{"--name", selectedContainer.Name, "--image", "TEMP_IMAGE_PLACEHOLDER"}
	} else { // Converting to Isolated
		newIsolatedHome, _ := getIsolatedHomePath(selectedContainer.Name)
		args = []string{"--name", selectedContainer.Name, "--image", "TEMP_IMAGE_PLACEHOLDER", "--home", newIsolatedHome}
	}
	finalMessage := fmt.Sprintf("‚úÖ Container '%s' successfully converted to %s!", selectedContainer.Name, targetType)

	done := make(chan bool)
	go showSpinner("Recreating container...", done)
	runCommand(containerRuntime, "stop", selectedContainer.Name)
	tempImageName := fmt.Sprintf("distrobox-convert-%s:%d", selectedContainer.ID, time.Now().Unix())

	for i, a := range args {
		if a == "TEMP_IMAGE_PLACEHOLDER" {
			args[i] = tempImageName
		}
	}

	_, err := runCommand(containerRuntime, "commit", selectedContainer.Name, tempImageName)
	if err != nil {
		done <- true
		logError("Failed to commit container to a temporary image. Aborting.")
		time.Sleep(5 * time.Second)
		return
	}

	defer func() {
		if tempImageName != "" {
			logInfo(fmt.Sprintf("Cleaning up temporary image %s...", tempImageName))
			_, errRmi := runCommand(containerRuntime, "rmi", tempImageName)
			if errRmi != nil {
				logWarning(fmt.Sprintf("Failed to clean up temporary image '%s'. You may want to remove it manually with '%s rmi %s'.", tempImageName, containerRuntime, tempImageName))
			}
		}
	}()

	_, err = runCommand("distrobox-rm", "-f", selectedContainer.Name)
	if err != nil {
		done <- true
		logError("Failed to remove the old container. You may need to clean up manually. Aborting.")
		time.Sleep(5 * time.Second)
		return
	}

	_, err = runCommand("distrobox-create", args...)
	if err != nil {
		done <- true
		logError("Failed to create the new container.")
		logInfo(fmt.Sprintf("The temporary image has been kept for manual recovery: %s", tempImageName))
		time.Sleep(5 * time.Second)
		return
	}

	if isIsolated { // If the original was isolated, delete its old home folder after conversion.
		os.RemoveAll(isolatedHomePath)
	}

	done <- true
	logSuccess(finalMessage)
	tempImageName = ""
	time.Sleep(1 * time.Second)
}

func handleDelete(containers []Container) {
	clearScreen()
	fmt.Printf("%s%süóëÔ∏è Delete Container%s\n\n", colorBold, colorRed, colorReset)
	printContainerList(containers)
	fmt.Printf("%s%sHint:%s This action is irreversible. Be absolutely sure.\n\n", colorYellow, colorUnderline, colorReset)
	containerIndex := selectItem("Enter the number of the container to DELETE", len(containers))
	if containerIndex == 0 {
		return
	}
	selectedContainer := containers[containerIndex-1]
	logWarning(fmt.Sprintf("You are about to permanently delete the container '%s'.", selectedContainer.Name))
	fmt.Printf("%sThis cannot be undone. Are you sure? (y/N): %s", colorRed, colorReset)
	if !confirmAction() {
		logInfo("Deletion cancelled by user.")
		time.Sleep(2 * time.Second)
		return
	}
	done := make(chan bool)
	go showSpinner("Deleting...", done)
	_, err := runCommand("distrobox-rm", "-f", selectedContainer.Name)
	done <- true
	if err != nil {
		logError(fmt.Sprintf("Failed to delete container '%s'.", selectedContainer.Name))
		logError(err.Error())
		time.Sleep(5 * time.Second)
		return
	}
	logSuccess(fmt.Sprintf("üóëÔ∏è Container '%s' has been deleted.", selectedContainer.Name))
	time.Sleep(1 * time.Second)
}

func handleHealthCheck(containers []Container) {
	clearScreen()
	fmt.Printf("%s%sü©∫ Health Check%s\n\n", colorBold, colorGreen, colorReset)
	printContainerList(containers)
	fmt.Printf("%s%sHint:%s This tests if a container can be entered to run a simple command.\n\n", colorYellow, colorUnderline, colorReset)

	containerIndex := selectItem("Enter the number of the container to check", len(containers))
	if containerIndex == 0 {
		return
	}
	selectedContainer := containers[containerIndex-1]

	logInfo(fmt.Sprintf("Performing health check on '%s'...", selectedContainer.Name))
	done := make(chan bool)
	go showSpinner("Checking...", done)

	output, err := runCommand("distrobox-enter", selectedContainer.Name, "--", "whoami")
	done <- true

	if err != nil {
		logError(fmt.Sprintf("Health check for '%s' FAILED.", selectedContainer.Name))
		logError("The container might be stopped, corrupted, or have configuration issues.")
		fmt.Println()
		logInfo("Full error details:")
		fmt.Println(output)
		time.Sleep(5 * time.Second)
		return
	}

	logSuccess(fmt.Sprintf("‚úÖ Health check for '%s' PASSED. The container is responsive.", selectedContainer.Name))
	time.Sleep(1 * time.Second)
}

// --- UI & Display Functions ---

func printHeader() {
	fmt.Printf("%s%sDistrobox Management Tool%s\n", colorBold, colorMagenta, colorReset)
	fmt.Printf("Distrobox v%s | Host OS: %s | Runtime: %s\n\n", distroboxVersion, hostDistroName, containerRuntime)
}

func displayMenu(containers []Container) {
	clearScreen()
	printHeader()
	fmt.Printf("%s=== Your Distrobox Containers ======================================%s\n", colorBlue, colorReset)
	if len(containers) == 0 {
		fmt.Printf("  %sNo Distrobox containers found.%s\n", colorYellow, colorReset)
	} else {
		printContainerList(containers)
	}
	fmt.Printf("%s====================================================================%s\n", colorBlue, colorReset)
	fmt.Printf(" %s1)%s Backup    %s2)%s Restore   %s3)%s Clone\n", colorGreen, colorReset, colorCyan, colorReset, colorCyan, colorReset)
	fmt.Printf(" %s4)%s Edit      %s5)%s Delete    %s6)%s Health Check\n", colorMagenta, colorReset, colorRed, colorReset, colorGreen, colorReset)
	fmt.Printf(" %s7)%s Exit\n", colorWhite, colorReset)
	fmt.Println()
}

func printContainerList(containers []Container) {
	for i, c := range containers {
		isIsolated, _ := isContainerIsolated(c.Name)
		typeColor := colorGreen
		typeText := "Standard"
		if isIsolated {
			typeColor = colorBlue
			typeText = "Isolated"
		}

		fmt.Printf("  %s%d.%s %-25s %s%-10s%s\n",
			colorBold, i+1, colorReset,
			c.Name,
			typeColor, typeText, colorReset,
		)
	}
}

func showSpinner(message string, done chan bool) {
	spinner := []string{"|", "/", "-", "\\"}
	i := 0
	for {
		select {
		case <-done:
			fmt.Printf("\r%s... Done!              \n", message)
			return
		default:
			fmt.Printf("\r%s %s ", message, spinner[i])
			i = (i + 1) % len(spinner)
			time.Sleep(100 * time.Millisecond)
		}
	}
}

// --- Helper & Utility Functions ---

func checkDependencies() {
	if !commandExists("distrobox") {
		logError("FATAL: 'distrobox' command not found. Please install it first.")
		os.Exit(1)
	}
	if commandExists("podman") {
		containerRuntime = "podman"
	} else if commandExists("docker") {
		containerRuntime = "docker"
	} else {
		logError("FATAL: Neither 'podman' nor 'docker' command found.")
		os.Exit(1)
	}
	if commandExists("zenity") {
		guiFilePicker = "zenity"
	} else if commandExists("kdialog") {
		guiFilePicker = "kdialog"
	}
	hasTar = commandExists("tar")

	output, err := runCommand("distrobox", "--version")
	if err == nil {
		parts := strings.Split(output, ":")
		if len(parts) > 1 {
			distroboxVersion = strings.TrimSpace(parts[1])
		} else {
			distroboxVersion = strings.TrimSpace(output)
		}
	} else {
		distroboxVersion = "Unknown"
	}

	content, err := os.ReadFile("/etc/os-release")
	if err == nil {
		re := regexp.MustCompile(`(?m)^PRETTY_NAME="?([^"\n]+)"?`)
		matches := re.FindStringSubmatch(string(content))
		if len(matches) > 1 {
			hostDistroName = matches[1]
		}
	} else {
		hostDistroName = "Unknown"
	}

	path, err := getContainerStoragePath()
	if err != nil {
		logError("Could not determine container storage path. Space checking will be disabled.")
		containerStoragePath = "/"
	} else {
		containerStoragePath = path
	}
}

func getContainers() ([]Container, error) {
	listOut, err := exec.Command("distrobox-list", "--no-color").Output()
	if err != nil {
		if strings.Contains(string(listOut), "No distroboxes found") || (err != nil && strings.Contains(err.Error(), "No distroboxes found")) {
			return []Container{}, nil
		}
		return nil, err
	}

	var containerNames []string
	lines := strings.Split(string(listOut), "\n")
	re := regexp.MustCompile(`\s*\|\s*`)
	for _, line := range lines {
		if !strings.Contains(line, "|") || strings.Contains(line, "ID   ") {
			continue
		}
		parts := re.Split(strings.TrimSpace(line), -1)
		if len(parts) >= 2 {
			containerNames = append(containerNames, strings.TrimSpace(parts[1]))
		}
	}

	if len(containerNames) == 0 {
		return []Container{}, nil
	}

	args := append([]string{"inspect"}, containerNames...)
	inspectOut, err := runCommand(containerRuntime, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to inspect containers: %w. This can happen if a container is in an error state", err)
	}

	var inspectResults []inspectData
	if err := json.Unmarshal([]byte(inspectOut), &inspectResults); err != nil {
		return nil, fmt.Errorf("failed to parse container inspect data: %w", err)
	}

	var containers []Container
	for _, data := range inspectResults {
		containerName := data.Config.Labels["distrobox.name"]
		if containerName == "" {
			containerName = strings.TrimPrefix(data.Name, "/")
		}

		containers = append(containers, Container{
			ID:    data.ID[:12],
			Name:  containerName,
			Image: data.Config.Image,
		})
	}
	return containers, nil
}

func getIsolatedHomePath(containerName string) (string, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}
	return filepath.Join(homeDir, ".local", "share", "distrobox", "homes", containerName), nil
}

func isContainerIsolated(containerName string) (bool, string) {
	isolatedHomePath, err := getIsolatedHomePath(containerName)
	if err != nil {
		return false, ""
	}
	if _, err := os.Stat(isolatedHomePath); err == nil {
		return true, isolatedHomePath
	}
	return false, ""
}

func selectDirectory(title string) (string, error) {
	if guiFilePicker != "" {
		var cmd *exec.Cmd
		if guiFilePicker == "zenity" {
			cmd = exec.Command("zenity", "--file-selection", "--directory", "--title="+title)
		} else {
			cmd = exec.Command("kdialog", "--getexistingdirectory", ".", "--title", title)
		}
		out, err := cmd.Output()
		if err == nil {
			return strings.TrimSpace(string(out)), nil
		}
		logWarning("GUI folder picker failed. Falling back to terminal.")
	}
	fmt.Printf("%s> Enter the full path to the destination directory: %s", colorBold, colorReset)
	path := readUserInput()
	if path == "" {
		return "", nil
	}
	if strings.HasPrefix(path, "~/") {
		homeDir, _ := os.UserHomeDir()
		path = filepath.Join(homeDir, path[2:])
	}
	info, err := os.Stat(path)
	if err != nil || !info.IsDir() {
		return "", fmt.Errorf("invalid or non-existent directory")
	}
	return path, nil
}

func selectFile(title string, filters ...string) (string, error) {
	if guiFilePicker != "" {
		var cmd *exec.Cmd
		if guiFilePicker == "zenity" {
			filterString := fmt.Sprintf("Distrobox Backups | %s", strings.Join(filters, " "))
			args := []string{
				"--file-selection", "--title=" + title, "--file-filter=" + filterString,
				"--file-filter=All Tar Files | *.tar", "--file-filter=All files | *",
			}
			cmd = exec.Command("zenity", args...)
		} else {
			kdialogFilter := fmt.Sprintf("Distrobox Backups (%s)|%s", strings.Join(filters, " "), strings.Join(filters, " "))
			cmd = exec.Command("kdialog", "--getopenfilename", ".", kdialogFilter, "--title", title)
		}
		out, err := cmd.Output()
		if err == nil {
			return strings.TrimSpace(string(out)), nil
		}
		logWarning("GUI file picker failed. Falling back to terminal.")
	}
	fmt.Printf("%s> Enter the full path to the backup file (.tar): %s", colorBold, colorReset)
	path := readUserInput()
	if path == "" {
		return "", nil
	}
	if strings.HasPrefix(path, "~/") {
		homeDir, _ := os.UserHomeDir()
		path = filepath.Join(homeDir, path[2:])
	}
	if _, err := os.Stat(path); err != nil {
		return "", fmt.Errorf("file not found")
	}
	return path, nil
}

func selectItem(prompt string, max int) int {
	for {
		fmt.Printf("%s> %s (1-%d): %s", colorBold, prompt, max, colorReset)
		input := readUserInput()
		if input == "" {
			return 0
		}
		choice, err := strconv.Atoi(input)
		if err == nil && choice > 0 && choice <= max {
			return choice
		}
		logWarning("Invalid input. Please enter a valid number.")
	}
}

func getContainerStoragePath() (string, error) {
	var format string
	if containerRuntime == "docker" {
		format = "{{.DockerRootDir}}"
	} else {
		format = "{{.Store.GraphRoot}}"
	}
	out, err := runCommand(containerRuntime, "info", "--format", format)
	if err != nil {
		return "", fmt.Errorf("could not get storage path from '%s info': %w", containerRuntime, err)
	}
	return strings.TrimSpace(out), nil
}

func getFreeDiskSpace(path string) (uint64, error) {
	var stat syscall.Statfs_t
	for {
		err := syscall.Statfs(path, &stat)
		if err == nil {
			break
		}
		if os.IsNotExist(err) {
			path = filepath.Dir(path)
			if path == "." || path == "/" {
				return 0, err
			}
			continue
		}
		return 0, err
	}
	return stat.Bavail * uint64(stat.Bsize), nil
}

func formatBytes(b uint64) string {
	const unit = 1024
	if b < unit {
		return fmt.Sprintf("%d B", b)
	}
	div, exp := int64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(b)/float64(div), "KMGTPE"[exp])
}

// --- STANDARD UTILITY FUNCTIONS ---

func runCommand(name string, args ...string) (string, error) {
	cmd := exec.Command(name, args...)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return string(output), fmt.Errorf("command '%s %s' failed: %w", name, strings.Join(args, " "), err)
	}
	return string(output), nil
}

func readUserInput() string {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Scan()
	return strings.TrimSpace(scanner.Text())
}

func confirmAction() bool {
	return strings.ToLower(readUserInput()) == "y"
}

func commandExists(cmd string) bool {
	_, err := exec.LookPath(cmd)
	return err == nil
}

func clearScreen() {
	var cmd *exec.Cmd
	if runtime.GOOS == "windows" {
		cmd = exec.Command("cmd", "/c", "cls")
	} else {
		cmd = exec.Command("clear")
	}
	cmd.Stdout = os.Stdout
	cmd.Run()
}

func logError(msg string) {
	fmt.Printf("%s%s‚ùå ERROR: %s%s\n", colorBold, colorRed, msg, colorReset)
}

func logWarning(msg string) {
	fmt.Printf("%s%s‚ö†Ô∏è  WARN: %s%s\n", colorBold, colorYellow, msg, colorReset)
}

func logInfo(msg string) {
	fmt.Printf("%s%s‚ÑπÔ∏è  INFO: %s%s\n", colorBold, colorCyan, msg, colorReset)
}

func logSuccess(msg string) {
	fmt.Printf("%s%s%s%s\n", colorBold, colorGreen, msg, colorReset)
}
